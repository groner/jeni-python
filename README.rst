.. DO NOT EDIT THIS FILE. EDIT README.rst.in.

===================================================
 ``jeni`` injects dependencies through annotations
===================================================

**jeni** lets you build applications and not e.g. web applications.

Overview
========

1. Configure dependencies that your system uses.
2. Give your code natural call interfaces accepting those dependencies.
3. Implement a **Provider** for each dependency, register with an **Injector**.

jeni runs on Python 2.7, Python 3.2, Python 3.3, and pypy.


Motivation
==========

Write code as its meant to be written, without pegging your call signatures to
some monolithic object that only applies to a specific runtime. This is about
more than just testing. This lets you write composable utilities.

jeni's design principle is to have all annotated callables usable in a context
that knows nothing about jeni. Any callable is as relevant to a fresh Python
REPL as it is to an injector.


Annotations
===========

Annotations are implemented as decorators for Python2.


Core API
========

``annotate``
------------

Annotate a callable with a decorator to provide data for Injectors.

Intended use::

    from jeni import annotate

    @annotate('foo', 'bar')
    def function(foo, bar):
        return

An `Injector` would then need to register providers for 'foo' and 'bar'
in order to apply this function; an injector with such providers can
apply the annotated function without any further information::

    injector.apply(function)

To get a partially applied function, to call later::

    fn = injector.partial(function)
    fn()

Annotation does not alter the callable's default behavior.
Call it normally::

    foo, bar = 'foo', 'bar'
    function(foo, bar)

Notes which are provided to `annotate` (above 'foo' and 'bar') can be
any hashable object (i.e. object able to be used as a key in a dict)
and is not limited to strings. If tuples are used as notes, they must
be of length 2, and `('maybe', ...)` is reserved.


``Provider``
------------

Provide a single prepared dependency.


``Provider.get(self, name=None)``
---------------------------------

Implement in subclass.

Annotations in the form of ``'object:name'`` will pass the `name` value
to the `get` method of the registered `Provider` (in this case, the
provider registered with the `Injector` to provide `object`). This
get-by-name pattern is useful for providers which have a dependency
which supports lookups by key (e.g. HTTP headers or records in a
key-value store).


``Provider.close(self)``
------------------------

By default, does nothing. Close objects as needed in subclass.


``Injector``
------------

Collects dependencies and reads annotations to inject them.


``Injector.__init__(self)``
---------------------------

An Injector could take arguments to init, but this base does not.

An Injector subclass inherits the provider registry of its base
classes, but can override any provider by re-registering notes. When
organizing a project, create an Injector subclass to serve as the
object to register all providers. This allows for the project to have
its own namespace of registered dependencies. This registry can be
customized by further subclasses, either for injecting mocks in testing
or providing alternative dependencies in a different runtime::

    from jeni import Injector as BaseInjector

    class Injector(BaseInjector):
        "Subclass provides namespace when registering providers."


``Injector.provider(cls, note, provider=None, name=False)``
-----------------------------------------------------------

Register a provider, either a Provider class or a generator.

Provider class::

    from jeni import Injector as BaseInjector
    from jeni import Provider

    class Injector(BaseInjector):
        pass

    @Injector.provider('hello')
    class HelloProvider(Provider):
        def get(self, name=None):
            if name is None:
                name = 'world'
            return 'Hello, {}!'.format(name)

Simple generator::

    @Injector.provider('answer')
    def answer():
        yield 42

If a generator supports get with a name argument::

    @Injector.provider('spam', name=True)
    def spam():
        count_str = yield 'spam'
        while True:
            count_str = yield 'spam' * int(count_str)

Registration can be a decorator or a direct method call::

    Injector.provider('hello', HelloProvider)


``Injector.factory(cls, note, fn=None)``
----------------------------------------

Register a function as a provider.

Function (name support is optional)::

    from jeni import Injector as BaseInjector
    from jeni import Provider

    class Injector(BaseInjector):
        pass

    @Injector.factory('echo')
    def echo(name=None):
        return name

Registration can be a decorator or a direct method call::

    Injector.factory('echo', echo)


``Injector.apply(self, fn)``
----------------------------

Fully apply annotated callable, returning callable's result.


``Injector.partial(self, fn)``
------------------------------

Partially apply annotated callable, returning a partial function.


``Injector.get(self, note)``
----------------------------

Resolve a single note into an object.


``Injector.close(self)``
------------------------

Close injector & injected Provider instances, including generators.

Provider close methods should not intentionally raise errors.
Specifically, if a dependency has transactions, the transaction should
be committed or rolled back before close is called, and not left as an
operation to be called during the close phase.

Providers are closed in the reverse order in which they were opened,
and each provider is only closed once. Providers are only closed if
they have successfully provided a dependency via get.


``Injector.enter(self)``
------------------------

Enter context-manager without with-block. See also: `exit`.

Useful for before- and after-hooks which cannot use a with-block.


``Injector.exit(self)``
-----------------------

Exit context-manager without with-block. See also: `enter`.


Additional API
==============

``annotate.maybe``
------------------

Wrap a keyword note to record that its resolution is optional.

Normally all annotations require fulfilled dependencies, but if a keyword
argument is annotated as `maybe`, then an injector does not pass unset
dependencies on apply::

    from jeni import annotate

    @annotate('foo', bar=annotate.maybe('bar'))
    def foobar(foo, bar=None):
        return


``InjectorProxy``
-----------------

Forwards getattr & getitem to enclosed injector.

If an injector has 'hello' registered::

    from jeni import InjectorProxy
    deps = InjectorProxy(injector)
    deps.hello

Get by name can use dict-style access::

    deps['hello:name']


License
=======

Copyright 2013-2014 Ron DuPlain <ron.duplain@gmail.com> (see AUTHORS file).

Released under the BSD License (see LICENSE file).
