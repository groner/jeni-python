#!/usr/bin/env python
"""An unsafe, naive .rst processor to support minimal module documentation."""

from __future__ import print_function

import inspect
import re
import sys


directive_re = re.compile(r'\.\. (eval|exec)::(.*)') # only supports one-liners


doc = """``{name}``
{underline}

{doc}
"""

def insert_doc(obj, u='-'):
    name = obj.__name__
    return doc.format(
        name=name,
        underline=u*(len(name)+4),
        doc=inspect.getdoc(obj))


args_doc = """``{name}{argspec}``
{underline}

{doc}
"""

def insert_args_doc(obj, u='-', ns=None):
    spec = inspect.getargspec(obj)
    if ns is None:
        name = obj.__name__
    else:
        name = '{}.{}'.format(ns, obj.__name__)
    argspec = inspect.formatargspec(*spec)
    return args_doc.format(
        name=name,
        underline=u*(len(name+argspec)+4),
        argspec=argspec,
        doc=inspect.getdoc(obj))


def process(filename):
    context = dict(
        insert_doc=insert_doc,
        insert_args_doc=insert_args_doc)
    yield '.. DO NOT EDIT THIS FILE. EDIT README.rst.in.\n\n'
    for line in open(filename):
        match = directive_re.search(line)
        if match is not None:
            expression = '{}\n'.format(match.group(2).strip())
            if match.group(1) == 'exec':
                result = None
                exec(expression, {}, context)
            else:
                result = eval(expression, {}, context)
            if result:
                yield result
            continue
        yield line


def main(argv, fd=sys.stdout):
    if len(argv) < 2:
        print('no input file', file=sys.stderr)
        return 2
    for filename in argv[1:]:
        for line in process(filename):
            fd.write(line)
            fd.flush()
    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))
